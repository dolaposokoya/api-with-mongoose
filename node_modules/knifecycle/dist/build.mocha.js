"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _yerror = _interopRequireDefault(require("yerror"));

var _build = _interopRequireDefault(require("./build"));

var _ = _interopRequireWildcard(require("."));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('buildInitializer', () => {
  async function aProvider() {}

  const mockedDepsHash = {
    NODE_ENV: (0, _.constant)('NODE_ENV', 'development'),
    dep1: (0, _.initializer)({
      inject: [],
      options: {},
      type: 'service',
      name: 'dep1'
    }, aProvider),
    dep2: (0, _.initializer)({
      inject: ['dep1', 'NODE_ENV'],
      options: {},
      type: 'provider',
      name: 'dep2'
    }, aProvider),
    dep3: (0, _.initializer)({
      inject: ['dep2', 'dep1', '?depOpt'],
      options: {},
      type: 'service',
      name: 'dep3'
    }, aProvider)
  };
  const initAutoloader = (0, _.initializer)({
    name: '$autoload',
    type: 'service',
    inject: [],
    options: {
      singleton: true
    }
  }, async () => {
    return async function $autoload(name) {
      return mockedDepsHash[name] ? Promise.resolve({
        path: `./services/${name}`,
        initializer: mockedDepsHash[name]
      }) : Promise.reject(new _yerror.default('E_UNMATCHED_DEPENDENCY', name));
    };
  });
  it('should build an initialization module', async () => {
    const $ = new _.default();
    $.register((0, _.constant)('PWD', '~/my-project'));
    $.register(initAutoloader);
    $.register(_build.default);
    const {
      buildInitializer
    } = await $.run(['buildInitializer']);
    const content = await buildInitializer(['dep1', 'finalMappedDep>dep3']);

    _assert.default.equal(content, `
// Definition batch #0
import initDep1 from './services/dep1';
const NODE_ENV = "development";

// Definition batch #1
import initDep2 from './services/dep2';

// Definition batch #2
import initDep3 from './services/dep3';

export async function initialize(services = {}) {
  // Initialization batch #0
  const batch0 = {
    dep1: initDep1({
    }),
    NODE_ENV: Promise.resolve(NODE_ENV),
  };

  await Promise.all(
    Object.keys(batch0)
    .map(key => batch0[key])
  );

  services['dep1'] = await batch0['dep1'];
  services['NODE_ENV'] = await batch0['NODE_ENV'];

  // Initialization batch #1
  const batch1 = {
    dep2: initDep2({
      dep1: services['dep1'],
      NODE_ENV: services['NODE_ENV'],
    }).then(provider => provider.service),
  };

  await Promise.all(
    Object.keys(batch1)
    .map(key => batch1[key])
  );

  services['dep2'] = await batch1['dep2'];

  // Initialization batch #2
  const batch2 = {
    dep3: initDep3({
      dep2: services['dep2'],
      dep1: services['dep1'],
      depOpt: services['depOpt'],
    }),
  };

  await Promise.all(
    Object.keys(batch2)
    .map(key => batch2[key])
  );

  services['dep3'] = await batch2['dep3'];

  return {
    dep1: services['dep1'],
    finalMappedDep: services['dep3'],
  };
}
`);
  });
});