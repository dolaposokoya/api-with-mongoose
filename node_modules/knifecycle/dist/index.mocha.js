"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _sinon = _interopRequireDefault(require("sinon"));

var _yerror = _interopRequireDefault(require("yerror"));

var _index = require("./index");

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint max-nested-callbacks:0 */
describe('Knifecycle', () => {
  let $;
  const ENV = {
    MY_ENV_VAR: 'plop'
  };
  const time = Date.now.bind(Date);

  function timeService() {
    return Promise.resolve(time);
  }

  function hashProvider(hash) {
    return Promise.resolve({
      service: hash
    });
  }

  beforeEach(() => {
    $ = new _index.Knifecycle();
  });
  describe('register', () => {
    describe('with constants', () => {
      it('should work with an object', () => {
        $.register((0, _index.constant)('ENV', ENV));
      });
      it('should work with a function', () => {
        $.register((0, _index.constant)('time', time));
      });
      it('should work when overriding a previously set constant', async () => {
        $.register((0, _index.constant)('TEST', 1));
        $.register((0, _index.constant)('TEST', 2));

        _assert.default.deepEqual((await $.run(['TEST'])), {
          TEST: 2
        });
      });
      it('should fail when overriding an initialized constant', async () => {
        $.register((0, _index.constant)('TEST', 1));

        _assert.default.deepEqual((await $.run(['TEST'])), {
          TEST: 1
        });

        try {
          $.register((0, _index.constant)('TEST', 2));
          throw new _yerror.default('E_UNEXPECTED_SUCCESS');
        } catch (err) {
          _assert.default.equal(err.code, 'E_INITIALIZER_ALREADY_INSTANCIATED');
        }
      });
    });
    describe('with services', () => {
      it('should  work with a service', () => {
        $.register((0, _index.service)(timeService, 'time'));
      });
      it('should work when overriding a previously set service', async () => {
        $.register((0, _index.service)(async () => () => 1, 'test'));
        $.register((0, _index.service)(async () => () => 2, 'test'));
        const {
          test
        } = await $.run(['test']);

        _assert.default.deepEqual(test(), 2);
      });
      it('should fail when overriding an initialized service', async () => {
        $.register((0, _index.service)(async () => () => 1, 'test'));
        const {
          test
        } = await $.run(['test']);

        _assert.default.deepEqual(test(), 1);

        try {
          $.register((0, _index.service)(async () => () => 2, 'test'));
          throw new _yerror.default('E_UNEXPECTED_SUCCESS');
        } catch (err) {
          _assert.default.equal(err.code, 'E_INITIALIZER_ALREADY_INSTANCIATED');
        }
      });
    });
    describe('with providers', () => {
      it('should  work with a provider', () => {
        $.register((0, _index.service)(hashProvider, 'hash'));
      });
      it('should work when overriding a previously set provider', async () => {
        $.register((0, _index.initializer)({
          type: 'provider',
          name: 'test',
          inject: []
        }, async () => ({
          service: 1
        })));
        $.register((0, _index.initializer)({
          type: 'provider',
          name: 'test',
          inject: []
        }, async () => ({
          service: 2
        })));
        const {
          test
        } = await $.run(['test']);

        _assert.default.deepEqual(test, 2);
      });
      it('should work when overriding a previously set singleton provider', async () => {
        $.register((0, _index.initializer)({
          type: 'provider',
          name: 'test',
          inject: [],
          options: {
            singleton: true
          }
        }, async () => ({
          service: 1
        })));
        $.register((0, _index.initializer)({
          type: 'provider',
          name: 'test',
          inject: []
        }, async () => ({
          service: 2
        })));
        const {
          test
        } = await $.run(['test']);

        _assert.default.deepEqual(test, 2);
      });
      it('should fail when overriding an initialized provider', async () => {
        $.register((0, _index.initializer)({
          type: 'provider',
          name: 'test',
          inject: [],
          options: {
            singleton: true
          }
        }, async () => ({
          service: 1
        })));
        const {
          test
        } = await $.run(['test']);

        _assert.default.deepEqual(test, 1);

        try {
          $.register((0, _index.initializer)({
            type: 'provider',
            name: 'test',
            inject: []
          }, async () => ({
            service: 2
          })));
          throw new _yerror.default('E_UNEXPECTED_SUCCESS');
        } catch (err) {
          _assert.default.equal(err.code, 'E_INITIALIZER_ALREADY_INSTANCIATED');
        }
      });
    });
    it('should fail when intitializer is no a function', () => {
      _assert.default.throws(() => {
        $.register('not_a_function');
      }, err => {
        _assert.default.deepEqual(err.code, 'E_BAD_INITIALIZER');

        _assert.default.deepEqual(err.params, ['not_a_function']);

        return true;
      });
    });
    it('should fail with no service name', () => {
      _assert.default.throws(() => {
        $.register(() => {});
      }, err => {
        _assert.default.deepEqual(err.code, 'E_ANONYMOUS_ANALYZER');

        _assert.default.deepEqual(err.params, []);

        return true;
      });
    });
    it('should fail with a bad service type', () => {
      _assert.default.throws(() => {
        const fn = () => {};

        fn[_index.SPECIAL_PROPS.NAME] = 'test';
        fn[_index.SPECIAL_PROPS.TYPE] = 'not_allowed_type';
        $.register(fn);
      }, err => {
        _assert.default.deepEqual(err.code, 'E_BAD_INITIALIZER_TYPE');

        _assert.default.deepEqual(err.params, ['test', 'not_allowed_type', _util.ALLOWED_INITIALIZER_TYPES]);

        return true;
      });
    });
    it('should fail with an undefined constant', () => {
      _assert.default.throws(() => {
        const fn = () => {};

        fn[_index.SPECIAL_PROPS.NAME] = 'THE_NUMBER';
        fn[_index.SPECIAL_PROPS.TYPE] = 'constant';
        fn[_index.SPECIAL_PROPS.VALUE] = {}.undef;
        fn[_index.SPECIAL_PROPS.OPTIONS] = {
          singleton: true
        };
        $.register(fn);
      }, err => {
        _assert.default.deepEqual(err.code, 'E_UNDEFINED_CONSTANT_INITIALIZER');

        _assert.default.deepEqual(err.params, ['THE_NUMBER']);

        return true;
      });
    });
    it('should fail with a constant that is not a singleton', () => {
      _assert.default.throws(() => {
        const fn = () => {};

        fn[_index.SPECIAL_PROPS.NAME] = 'THE_NUMBER';
        fn[_index.SPECIAL_PROPS.TYPE] = 'constant';
        fn[_index.SPECIAL_PROPS.VALUE] = NaN;
        fn[_index.SPECIAL_PROPS.OPTIONS] = {
          singleton: false
        };
        $.register(fn);
      }, err => {
        _assert.default.deepEqual(err.code, 'E_NON_SINGLETON_CONSTANT_INITIALIZER');

        _assert.default.deepEqual(err.params, ['THE_NUMBER']);

        return true;
      });
    });
    it('should fail with a non constant that has a value', () => {
      _assert.default.throws(() => {
        const fn = () => {};

        fn[_index.SPECIAL_PROPS.NAME] = 'myService';
        fn[_index.SPECIAL_PROPS.TYPE] = 'service';
        fn[_index.SPECIAL_PROPS.VALUE] = 42;
        $.register(fn);
      }, err => {
        _assert.default.deepEqual(err.code, 'E_BAD_VALUED_NON_CONSTANT_INITIALIZER');

        _assert.default.deepEqual(err.params, ['myService']);

        return true;
      });
    });
    it('should fail with special autoload intitializer that is not a singleton', () => {
      _assert.default.throws(() => {
        $.register((0, _index.initializer)({
          name: '$autoload',
          type: 'provider'
        }, () => {}));
      }, err => {
        _assert.default.deepEqual(err.code, 'E_BAD_AUTOLOADER');

        _assert.default.deepEqual(err.params, [{}]);

        return true;
      });
    });
  });
  describe('provider', () => {
    it('should register provider', () => {
      $.register((0, _index.provider)(hashProvider, 'hash'));
    });
    it('should fail with direct circular dependencies', () => {
      _assert.default.throws(() => {
        $.register((0, _index.provider)(hashProvider, 'hash', ['hash']));
      }, err => {
        _assert.default.deepEqual(err.code, 'E_CIRCULAR_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['hash']);

        return true;
      });
    });
    it('should fail with direct circular dependencies on mapped services', () => {
      _assert.default.throws(() => {
        $.register((0, _index.provider)(hashProvider, 'hash', ['hash>lol']));
      }, err => {
        _assert.default.deepEqual(err.code, 'E_CIRCULAR_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['hash']);

        return true;
      });
    });
    it('should fail with circular dependencies', () => {
      _assert.default.throws(() => {
        $.register((0, _index.provider)((0, _index.inject)(['hash3'], hashProvider), 'hash'));
        $.register((0, _index.provider)((0, _index.inject)(['hash'], hashProvider), 'hash1'));
        $.register((0, _index.provider)((0, _index.inject)(['hash1'], hashProvider), 'hash2'));
        $.register((0, _index.provider)((0, _index.inject)(['hash'], hashProvider), 'hash3'));
      }, err => {
        _assert.default.deepEqual(err.code, 'E_CIRCULAR_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['hash3', 'hash', 'hash3']);

        return true;
      });
    });
    it('should fail with deeper circular dependencies', () => {
      _assert.default.throws(() => {
        $.register((0, _index.provider)((0, _index.inject)(['hash1'], hashProvider), 'hash'));
        $.register((0, _index.provider)((0, _index.inject)(['hash2'], hashProvider), 'hash1'));
        $.register((0, _index.provider)((0, _index.inject)(['hash3'], hashProvider), 'hash2'));
        $.register((0, _index.provider)((0, _index.inject)(['hash'], hashProvider), 'hash3'));
      }, err => {
        _assert.default.deepEqual(err.code, 'E_CIRCULAR_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['hash3', 'hash', 'hash1', 'hash2', 'hash3']);

        return true;
      });
    });
    it('should fail with circular dependencies on mapped services', () => {
      _assert.default.throws(() => {
        $.register((0, _index.provider)((0, _index.inject)(['hash3>aHash3'], hashProvider), 'hash'));
        $.register((0, _index.provider)((0, _index.inject)(['hash>aHash'], hashProvider), 'hash1'));
        $.register((0, _index.provider)((0, _index.inject)(['hash1>aHash1'], hashProvider), 'hash2'));
        $.register((0, _index.provider)((0, _index.inject)(['hash>aHash'], hashProvider), 'hash3'));
      }, err => {
        _assert.default.deepEqual(err.code, 'E_CIRCULAR_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['hash3', 'hash>aHash', 'hash3>aHash3']);

        return true;
      });
    });
  });
  describe('run', () => {
    it('should work with no dependencies', async () => {
      const dependencies = await $.run([]);

      _assert.default.deepEqual(dependencies, {});
    });
    it('should work with constant dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      const dependencies = await $.run(['time', 'ENV']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'ENV']);

      _assert.default.deepEqual(dependencies, {
        ENV,
        time
      });
    });
    it('should work with service dependencies', async () => {
      $.register((0, _index.service)((0, _index.inject)(['time'], function sampleService({
        time
      }) {
        return Promise.resolve(typeof time);
      }), 'sample'));
      $.register((0, _index.constant)('time', time));
      const dependencies = await $.run(['sample']);

      _assert.default.deepEqual(Object.keys(dependencies), ['sample']);

      _assert.default.deepEqual(dependencies, {
        sample: 'function'
      });
    });
    it('should work with simple dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      const dependencies = await $.run(['time', 'hash']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash']);

      _assert.default.deepEqual(dependencies, {
        hash: {
          ENV
        },
        time
      });
    });
    it('should work with given optional dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('DEBUG', {}));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV', '?DEBUG']));
      const dependencies = await $.run(['time', 'hash']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash']);

      _assert.default.deepEqual(dependencies, {
        hash: {
          ENV,
          DEBUG: {}
        },
        time
      });
    });
    it('should work with lacking optional dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV', '?DEBUG']));
      const dependencies = await $.run(['time', 'hash']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash']);

      _assert.default.deepEqual(dependencies, {
        hash: {
          ENV,
          DEBUG: {}.undef
        },
        time
      });
    });
    it('should work with deeper dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['hash']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['hash1']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash4', ['hash3']));
      $.register((0, _index.provider)(hashProvider, 'hash5', ['hash4']));
      const dependencies = await $.run(['hash5', 'time']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash5', 'time']);
    });
    it('should instanciate services once', async () => {
      const timeServiceStub = _sinon.default.spy(timeService);

      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.service)(timeServiceStub, 'time'));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV', 'time']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['ENV', 'time']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['ENV', 'time']));
      const dependencies = await $.run(['hash', 'hash2', 'hash3', 'time']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash', 'hash2', 'hash3', 'time']);

      _assert.default.deepEqual(timeServiceStub.args, [[{}]]);
    });
    it('should instanciate a single mapped service', async () => {
      const providerStub = _sinon.default.stub().returns(Promise.resolve({
        service: 'stub'
      }));

      const providerStub2 = _sinon.default.stub().returns(Promise.resolve({
        service: 'stub2'
      }));

      $.register((0, _index.provider)(providerStub, 'mappedStub', ['stub2>mappedStub2']));
      $.register((0, _index.provider)(providerStub2, 'mappedStub2'));
      const dependencies = await $.run(['stub>mappedStub']);

      _assert.default.deepEqual(dependencies, {
        stub: 'stub'
      });

      _assert.default.deepEqual(providerStub.args, [[{
        stub2: 'stub2'
      }]]);
    });
    it('should instanciate several services with mappings', async () => {
      const timeServiceStub = _sinon.default.spy(timeService);

      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.service)(timeServiceStub, 'aTime'));
      $.register((0, _index.provider)(hashProvider, 'aHash', ['ENV', 'time>aTime']));
      $.register((0, _index.provider)(hashProvider, 'aHash2', ['ENV', 'hash>aHash']));
      $.register((0, _index.provider)(hashProvider, 'aHash3', ['ENV', 'hash>aHash']));
      const dependencies = await $.run(['hash2>aHash2', 'hash3>aHash3', 'time>aTime']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash2', 'hash3', 'time']);

      _assert.default.deepEqual(timeServiceStub.args, [[{}]]);
    });
    it('should fail with bad service', async () => {
      $.register((0, _index.service)(() => {}, 'lol'));

      try {
        await $.run(['lol']);
        throw new Error('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.deepEqual(err.code, 'E_BAD_SERVICE_PROMISE');

        _assert.default.deepEqual(err.params, ['lol']);
      }
    });
    it('should fail with bad provider', async () => {
      $.register((0, _index.provider)(() => {}, 'lol'));

      try {
        await $.run(['lol']);
        throw new Error('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.deepEqual(err.code, 'E_BAD_SERVICE_PROVIDER');

        _assert.default.deepEqual(err.params, ['lol']);
      }
    });
    it('should fail with bad service in a provider', async () => {
      $.register((0, _index.provider)(() => Promise.resolve(), 'lol'));

      try {
        await $.run(['lol']);
        throw new Error('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.deepEqual(err.code, 'E_BAD_SERVICE_PROVIDER');

        _assert.default.deepEqual(err.params, ['lol']);
      }
    });
    it('should fail with undeclared dependencies', async () => {
      try {
        await $.run(['lol']);
        throw new Error('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.deepEqual(err.code, 'E_UNMATCHED_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['lol']);
      }
    });
    it('should fail with undeclared dependencies upstream', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV', 'hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['ENV', 'lol']));

      try {
        await $.run(['time', 'hash']);
        throw new Error('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.deepEqual(err.code, 'E_UNMATCHED_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['hash', 'hash2', 'lol']);
      }
    });
    it('should provide a fatal error handler', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(dbProvider, 'db', ['ENV']));
      $.register((0, _index.provider)(processProvider, 'process', ['$fatalError']));

      function processProvider({
        $fatalError
      }) {
        return Promise.resolve({
          service: {
            fatalErrorPromise: $fatalError.promise
          }
        });
      }

      async function dbProvider({
        ENV
      }) {
        let service;
        const fatalErrorPromise = new Promise((resolve, reject) => {
          service = Promise.resolve({
            resolve,
            reject,
            ENV
          });
        });
        return {
          service,
          fatalErrorPromise
        };
      }

      const {
        process,
        db
      } = await $.run(['time', 'hash', 'db', 'process']);

      try {
        db.reject(new Error('E_DB_ERROR'));
        await process.fatalErrorPromise;
        throw new Error('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.deepEqual(err.message, 'E_DB_ERROR');
      }
    });
  });
  describe('autoload', () => {
    it('should work with lacking autoloaded dependencies', async () => {
      $.register((0, _index.initializer)({
        type: 'service',
        name: '$autoload',
        inject: [],
        options: {
          singleton: true
        }
      }, async () => async serviceName => ({
        path: '/path/of/debug',
        initializer: (0, _index.initializer)({
          type: 'service',
          name: 'DEBUG',
          inject: []
        }, async () => 'THE_DEBUG:' + serviceName)
      })));
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV', '?DEBUG']));
      const dependencies = await $.run(['time', 'hash']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash']);

      _assert.default.deepEqual(dependencies, {
        hash: {
          ENV,
          DEBUG: 'THE_DEBUG:DEBUG'
        },
        time
      });
    });
    it('should work with deeper several lacking dependencies', async () => {
      $.register((0, _index.initializer)({
        name: '$autoload',
        type: 'service',
        options: {
          singleton: true
        }
      }, async () => async serviceName => ({
        path: `/path/to/${serviceName}`,
        initializer: (0, _index.initializer)({
          type: 'provider',
          name: serviceName,
          inject: 'hash2' === serviceName ? ['hash1'] : 'hash4' === serviceName ? ['hash3'] : []
        }, hashProvider)
      })));
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['hash']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash5', ['hash4']));
      const dependencies = await $.run(['hash5', 'time']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash5', 'time']);
    });
    it('should work with various dependencies', async () => {
      $.register((0, _index.provider)(hashProvider, 'hash', ['hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['?ENV']));
      $.register((0, _index.constant)('DEBUG', 1));
      $.register((0, _index.initializer)({
        type: 'service',
        name: '$autoload',
        inject: ['?ENV', 'DEBUG'],
        options: {
          singleton: true
        }
      }, async () => async serviceName => {
        if ('ENV' === serviceName) {
          throw new _yerror.default('E_UNMATCHED_DEPENDENCY');
        }

        return {
          path: '/path/of/debug',
          initializer: (0, _index.initializer)({
            type: 'service',
            name: 'hash2',
            inject: ['hash3']
          }, async () => 'THE_HASH:' + serviceName)
        };
      }));
      const dependencies = await $.run(['hash', '?ENV']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash', 'ENV']);
    });
    it('should instanciate services once', async () => {
      $.register((0, _index.initializer)({
        name: '$autoload',
        type: 'service',
        options: {
          singleton: true
        }
      }, async () => async serviceName => ({
        path: `/path/to/${serviceName}`,
        initializer: (0, _index.initializer)({
          type: 'provider',
          name: serviceName,
          inject: ['ENV', 'time']
        }, hashProvider)
      })));

      const timeServiceStub = _sinon.default.spy(timeService);

      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.service)(timeServiceStub, 'time'));
      $.register((0, _index.provider)(hashProvider, 'hash', ['hash1', 'hash2', 'hash3']));
      $.register((0, _index.provider)(hashProvider, 'hash_', ['hash1', 'hash2', 'hash3']));
      const dependencies = await $.run(['hash', 'hash_', 'hash3']);

      _assert.default.deepEqual(timeServiceStub.args, [[{}]]);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash', 'hash_', 'hash3']);
    });
    it('should fail when autoload does not exists', async () => {
      try {
        await $.run(['test']);
        throw new _yerror.default('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.equal(err.code, 'E_UNMATCHED_DEPENDENCY');
      }
    });
    it('should fail when autoloaded dependencies are not found', async () => {
      $.register((0, _index.initializer)({
        type: 'service',
        name: '$autoload',
        inject: [],
        options: {
          singleton: true
        }
      }, async () => async serviceName => {
        throw new _yerror.default('E_CANNOT_AUTOLOAD', serviceName);
      }));

      try {
        await $.run(['test']);
        throw new _yerror.default('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.equal(err.code, 'E_CANNOT_AUTOLOAD');

        _assert.default.deepEqual(err.params, ['test']);
      }
    });
    it('should fail when autoloaded dependencies are not initializers', async () => {
      $.register((0, _index.initializer)({
        type: 'service',
        name: '$autoload',
        inject: [],
        options: {
          singleton: true
        }
      }, async () => async () => 'not_an_initializer'));

      try {
        await $.run(['test']);
        throw new _yerror.default('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.equal(err.code, 'E_BAD_AUTOLOADED_INITIALIZER');

        _assert.default.deepEqual(err.params, ['test', {}.undef]);
      }
    });
    it('should fail when autoloaded dependencies are not right initializers', async () => {
      $.register((0, _index.initializer)({
        type: 'service',
        name: '$autoload',
        inject: [],
        options: {
          singleton: true
        }
      }, async () => async serviceName => ({
        path: '/path/of/debug',
        initializer: (0, _index.initializer)({
          type: 'service',
          name: 'not-' + serviceName,
          inject: []
        }, async () => 'THE_TEST:' + serviceName)
      })));

      try {
        await $.run(['test']);
        throw new _yerror.default('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.equal(err.code, 'E_AUTOLOADED_INITIALIZER_MISMATCH');

        _assert.default.deepEqual(err.params, ['test', 'not-test']);
      }
    });
    it('should fail when autoload depends on autoloaded/unexisting dependencies', async () => {
      $.register((0, _index.initializer)({
        type: 'service',
        name: '$autoload',
        inject: ['ENV'],
        options: {
          singleton: true
        }
      }, async () => async serviceName => ({
        path: '/path/of/debug',
        initializer: (0, _index.initializer)({
          type: 'service',
          name: 'DEBUG',
          inject: []
        }, async () => 'THE_DEBUG:' + serviceName)
      })));

      try {
        await $.run(['test']);
        throw new _yerror.default('E_UNEXPECTED_SUCCESS');
      } catch (err) {
        _assert.default.equal(err.code, 'E_AUTOLOADER_DYNAMIC_DEPENDENCY');

        _assert.default.deepEqual(err.params, ['ENV']);
      }
    });
  });
  describe('$injector', () => {
    it('should work with no dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      const dependencies = await $.run(['time', 'hash', '$injector']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash', '$injector']);

      const injectDependencies = await dependencies.$injector([]);

      _assert.default.deepEqual(Object.keys(injectDependencies), []);

      _assert.default.deepEqual(injectDependencies, {});
    });
    it('should work with same dependencies then the running silo', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      const dependencies = await $.run(['time', 'hash', '$injector']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash', '$injector']);

      const injectDependencies = await dependencies.$injector(['time', 'hash']);

      _assert.default.deepEqual(Object.keys(injectDependencies), ['time', 'hash']);

      _assert.default.deepEqual(injectDependencies, {
        hash: {
          ENV
        },
        time
      });
    });
    it('should work with name mapping', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      const dependencies = await $.run(['time', 'hash', '$injector']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash', '$injector']);

      const injectDependencies = await dependencies.$injector(['aTime>time', 'aHash>hash']);

      _assert.default.deepEqual(Object.keys(injectDependencies), ['aTime', 'aHash']);

      _assert.default.deepEqual(injectDependencies, {
        aHash: {
          ENV
        },
        aTime: time
      });
    });
    it('should work with non instanciated dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      const dependencies = await $.run(['time', '$injector']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', '$injector']);

      const injectDependencies = await dependencies.$injector(['time', 'hash']);

      _assert.default.deepEqual(Object.keys(injectDependencies), ['time', 'hash']);

      _assert.default.deepEqual(injectDependencies, {
        hash: {
          ENV
        },
        time
      });
    });
    it('should create dependencies when not declared as singletons', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      const [{
        hash
      }, {
        hash: sameHash
      }] = await Promise.all([$.run(['hash']), $.run(['hash'])]);

      _assert.default.notEqual(hash, sameHash);

      const {
        hash: yaSameHash
      } = await $.run(['hash']);

      _assert.default.notEqual(hash, yaSameHash);
    });
    it('should reuse dependencies when declared as singletons', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV'], {
        singleton: true
      }));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['ENV'], {
        singleton: true
      }));
      const [{
        hash,
        hash2
      }, {
        hash: sameHash,
        hash2: sameHash2
      }] = await Promise.all([$.run(['hash']), $.run(['hash']), $.run(['hash2']), $.run(['hash2'])]);

      _assert.default.equal(hash, sameHash);

      _assert.default.equal(hash2, sameHash2);

      const {
        hash: yaSameHash
      } = await $.run(['hash']);

      _assert.default.equal(hash, yaSameHash);
    });
  });
  describe('$destroy', () => {
    it('should work even with one silo and no dependencies', async () => {
      const dependencies = await $.run(['$destroy']);

      _assert.default.equal(typeof dependencies.$destroy, 'function');

      await dependencies.$destroy();
    });
    it('should work with several silos and dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV'], {
        singleton: true
      }));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['ENV']));
      const [dependencies] = await Promise.all([$.run(['$destroy']), $.run(['ENV', 'hash', 'hash1', 'time']), $.run(['ENV', 'hash', 'hash2'])]);

      _assert.default.equal(typeof dependencies.$destroy, 'function');

      await dependencies.$destroy();
    });
    it('should work when trigered from several silos simultaneously', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['ENV']));
      const dependenciesBuckets = await Promise.all([$.run(['$destroy']), $.run(['$destroy', 'ENV', 'hash', 'hash1', 'time']), $.run(['$destroy', 'ENV', 'hash', 'hash2'])]);
      await Promise.all(dependenciesBuckets.map(dependencies => dependencies.$destroy()));
    });
    it('should work when a silo shutdown is in progress', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['ENV']));
      const [dependencies1, dependencies2] = await Promise.all([$.run(['$destroy']), $.run(['$dispose', 'ENV', 'hash', 'hash1', 'time']), $.run(['ENV', 'hash', 'hash2'])]);
      await Promise.all([dependencies2.$dispose(), dependencies1.$destroy()]);
    });
    it('should disallow new runs', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['ENV']));
      const dependencies = await $.run(['$destroy']);

      _assert.default.equal(typeof dependencies.$destroy, 'function');

      await dependencies.$destroy();

      try {
        await $.run(['ENV', 'hash', 'hash1']);
        throw new _yerror.default('E_UNEXPECTED_SUCCES');
      } catch (err) {
        _assert.default.equal(err.code, 'E_INSTANCE_DESTROYED');
      }
    });
  });
  describe('$dispose', () => {
    it('should work with no dependencies', async () => {
      const dependencies = await $.run(['$dispose']);

      _assert.default.equal(typeof dependencies.$dispose, 'function');

      return dependencies.$dispose();
    });
    it('should work with constant dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      const dependencies = await $.run(['time', 'ENV', '$dispose']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'ENV', '$dispose']);

      await dependencies.$dispose();
    });
    it('should work with simple dependencies', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      const dependencies = await $.run(['time', 'hash', '$dispose']);

      _assert.default.deepEqual(Object.keys(dependencies), ['time', 'hash', '$dispose']);

      await dependencies.$dispose();
    });
    it('should work with deeper dependencies', async () => {
      let shutdownCallResolve;
      let shutdownResolve;
      const shutdownCallPromise = new Promise(resolve => {
        shutdownCallResolve = resolve;
      });

      const shutdownStub = _sinon.default.spy(() => {
        shutdownCallResolve();
        return new Promise(resolve => {
          shutdownResolve = resolve;
        });
      });

      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['hash']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['hash1']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash4', ['hash3']));
      $.register((0, _index.provider)(hashProvider, 'hash5', ['hash4']));
      $.register((0, _index.provider)(() => Promise.resolve({
        service: {
          shutdownStub,
          shutdownResolve
        },
        dispose: shutdownStub
      }), 'shutdownChecker', ['hash4']));
      const dependencies = await $.run(['hash5', 'time', '$dispose', 'shutdownChecker']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash5', 'time', '$dispose', 'shutdownChecker']);

      const finalPromise = shutdownCallPromise.then(() => {
        _assert.default.deepEqual(shutdownStub.args, [[]]);

        shutdownResolve();
      });
      await dependencies.$dispose();
      await finalPromise;
    });
    it('should work with deeper multi used dependencies', async () => {
      let shutdownCallResolve;
      let shutdownResolve;
      const shutdownCallPromise = new Promise(resolve => {
        shutdownCallResolve = resolve;
      });

      const shutdownStub = _sinon.default.spy(() => {
        shutdownCallResolve();
        return new Promise(resolve => {
          shutdownResolve = resolve;
        });
      });

      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(() => Promise.resolve({
        service: {
          shutdownStub,
          shutdownResolve
        },
        dispose: shutdownStub
      }), 'shutdownChecker', ['hash']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['shutdownChecker']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['shutdownChecker']));
      const dependencies = await $.run(['hash1', 'hash2', '$dispose', 'shutdownChecker']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash1', 'hash2', '$dispose', 'shutdownChecker']);

      const finalPromise = shutdownCallPromise.then(() => {
        _assert.default.deepEqual(shutdownStub.args, [[]]);

        shutdownResolve();
      });
      await dependencies.$dispose();
      await finalPromise;
    });
    it('should delay service shutdown to their deeper dependencies', async () => {
      const servicesShutdownCalls = _sinon.default.spy(() => Promise.resolve());

      $.register((0, _index.provider)(() => Promise.resolve({
        service: {},
        dispose: servicesShutdownCalls.bind(null, 'hash')
      }), 'hash'));
      $.register((0, _index.provider)(() => Promise.resolve({
        service: {},
        dispose: servicesShutdownCalls.bind(null, 'hash1')
      }), 'hash1', ['hash']));
      $.register((0, _index.provider)(() => Promise.resolve({
        service: {},
        dispose: servicesShutdownCalls.bind(null, 'hash2')
      }), 'hash2', ['hash1', 'hash']));
      const dependencies = await $.run(['hash2', '$dispose']);

      _assert.default.deepEqual(Object.keys(dependencies), ['hash2', '$dispose']);

      await dependencies.$dispose();

      _assert.default.deepEqual(servicesShutdownCalls.args, [['hash2'], ['hash1'], ['hash']]);
    });
    it('should not shutdown singleton dependencies if used elsewhere', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV'], {
        singleton: true
      }));
      const {
        hash
      } = await $.run(['time', 'hash']);
      const dependencies = await $.run(['time', 'hash', '$dispose']);

      _assert.default.equal(dependencies.hash, hash);

      await dependencies.$dispose();
      const newDependencies = await $.run(['time', 'hash']);

      _assert.default.equal(newDependencies.hash, hash);
    });
    it('should shutdown singleton dependencies if not used elsewhere', async () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV'], {
        singleton: true
      }));
      const {
        hash,
        $dispose
      } = await $.run(['time', 'hash', '$dispose']);
      await $dispose();
      const dependencies = await $.run(['time', 'hash']);

      _assert.default.notEqual(dependencies.hash, hash);
    });
  });
  describe('toMermaidGraph', () => {
    it('should print nothing when no dependency', () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));

      _assert.default.equal($.toMermaidGraph(), '');
    });
    it('should print a dependency graph', () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['hash']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['hash1']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash4', ['hash3']));
      $.register((0, _index.provider)(hashProvider, 'hash5', ['hash4']));

      _assert.default.equal($.toMermaidGraph(), 'graph TD\n' + '  hash-->ENV\n' + '  hash1-->hash\n' + '  hash2-->hash1\n' + '  hash3-->hash2\n' + '  hash4-->hash3\n' + '  hash5-->hash4');
    });
    it('should allow custom shapes', () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['hash']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['hash1']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash4', ['hash3']));
      $.register((0, _index.provider)(hashProvider, 'hash5', ['hash4']));

      _assert.default.equal($.toMermaidGraph({
        shapes: [{
          pattern: /^hash([0-9]+)$/,
          template: '$0(($1))'
        }, {
          pattern: /^[A-Z_]+$/,
          template: '$0{$0}'
        }, {
          pattern: /^.+$/,
          template: '$0[$0]'
        }]
      }), 'graph TD\n' + '  hash[hash]-->ENV{ENV}\n' + '  hash1((1))-->hash[hash]\n' + '  hash2((2))-->hash1((1))\n' + '  hash3((3))-->hash2((2))\n' + '  hash4((4))-->hash3((3))\n' + '  hash5((5))-->hash4((4))');
    });
    it('should allow custom styles', () => {
      $.register((0, _index.constant)('ENV', ENV));
      $.register((0, _index.constant)('time', time));
      $.register((0, _index.provider)(hashProvider, 'hash', ['ENV']));
      $.register((0, _index.provider)(hashProvider, 'hash1', ['hash']));
      $.register((0, _index.provider)(hashProvider, 'hash2', ['hash1']));
      $.register((0, _index.provider)(hashProvider, 'hash3', ['hash2']));
      $.register((0, _index.provider)(hashProvider, 'hash4', ['hash3']));
      $.register((0, _index.provider)(hashProvider, 'hash5', ['hash4']));

      _assert.default.equal($.toMermaidGraph({
        classes: {
          exotic: 'fill:#f9f,stroke:#333,stroke-width:4px;'
        },
        styles: [{
          pattern: /^hash([0-9]+)$/,
          className: 'exotic'
        }, {
          pattern: /^hash([0-9]+)$/,
          className: 'notapplied'
        }],
        shapes: [{
          pattern: /^hash([0-9]+)$/,
          template: '$0(($1))'
        }, {
          pattern: /^[A-Z_]+$/,
          template: '$0{$0}'
        }, {
          pattern: /^.+$/,
          template: '$0[$0]'
        }]
      }), 'graph TD\n' + '  hash[hash]-->ENV{ENV}\n' + '  hash1((1))-->hash[hash]\n' + '  hash2((2))-->hash1((1))\n' + '  hash3((3))-->hash2((2))\n' + '  hash4((4))-->hash3((3))\n' + '  hash5((5))-->hash4((4))\n' + '  classDef exotic fill:#f9f,stroke:#333,stroke-width:4px;\n' + '  class hash1 exotic;\n' + '  class hash2 exotic;\n' + '  class hash3 exotic;\n' + '  class hash4 exotic;\n' + '  class hash5 exotic;');
    });
  });
});