"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _sinon = _interopRequireDefault(require("sinon"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function aProvider() {}

describe('reuseSpecialProps', () => {
  it('should work', () => {
    // We can safely ignore coverage here since the
    // function are here just as placeholders

    /* istanbul ignore next */
    function from() {
      return 'from';
    }
    /* istanbul ignore next */


    function to() {
      return 'to';
    }

    from.$name = 'from';
    from.$type = 'service';
    from.$inject = ['ki', 'kooo', 'lol'];
    from.$options = {
      singleton: false
    };
    from.$extra = {
      httpHandler: true
    };
    const newFn = (0, _util.reuseSpecialProps)(from, to);

    _assert.default.notEqual(newFn, to);

    _assert.default.equal(newFn.$name, from.$name);

    _assert.default.equal(newFn.$type, from.$type);

    _assert.default.notEqual(newFn.$inject, from.$inject);

    _assert.default.deepEqual(newFn.$inject, from.$inject);

    _assert.default.notEqual(newFn.$options, from.$options);

    _assert.default.deepEqual(newFn.$options, from.$options);

    _assert.default.notEqual(newFn.$extra, from.$extra);

    _assert.default.deepEqual(newFn.$extra, from.$extra);

    const newFn2 = (0, _util.reuseSpecialProps)(from, to, {
      $name: 'yolo'
    });

    _assert.default.notEqual(newFn2, to);

    _assert.default.equal(newFn2.$name, 'yolo');

    _assert.default.equal(newFn2.$type, from.$type);

    _assert.default.notEqual(newFn2.$inject, from.$inject);

    _assert.default.deepEqual(newFn2.$inject, from.$inject);

    _assert.default.notEqual(newFn2.$options, from.$options);

    _assert.default.deepEqual(newFn2.$options, from.$options);

    _assert.default.notEqual(newFn.$extra, from.$extra);

    _assert.default.deepEqual(newFn.$extra, from.$extra);
  });
});
describe('wrapInitializer', () => {
  it('should work', async () => {
    function baseInitializer() {
      return Promise.resolve(() => 'test');
    }

    baseInitializer.$name = 'baseInitializer';
    baseInitializer.$type = 'service';
    baseInitializer.$inject = ['log'];
    baseInitializer.$options = {
      singleton: false
    };
    baseInitializer.$extra = {
      httpHandler: false
    };

    const log = _sinon.default.stub();

    const newInitializer = (0, _util.wrapInitializer)(({
      log
    }, service) => {
      log('Wrapping...');
      return () => service() + '-wrapped';
    }, baseInitializer);
    const service = await newInitializer({
      log
    });

    _assert.default.equal(service(), 'test-wrapped');

    _assert.default.deepEqual(log.args, [['Wrapping...']]);
  });
});
describe('inject', () => {
  it('should allow to decorate an initializer with dependencies', () => {
    const dependencies = ['ENV'];
    const newInitializer = (0, _util.inject)(dependencies, aProvider);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with mapped dependencies', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const newInitializer = (0, _util.inject)(dependencies, aProvider);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should fail with a constant', () => {
    _assert.default.throws(() => {
      (0, _util.inject)(['test'], (0, _util.constant)('test', 'test'));
    }, /E_BAD_INJECT_IN_CONSTANT/);
  });
});
describe('autoInject', () => {
  it('should allow to decorate an initializer with dependencies', () => {
    const baseProvider = async ({
      ENV,
      mysql: db
    }) => async () => ({
      ENV,
      db
    });

    const dependencies = ['ENV', 'mysql'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with a function name', () => {
    async function baseProvider({
      ENV,
      mysql: db
    }) {
      async () => ({
        ENV,
        db
      });
    }

    const dependencies = ['ENV', 'mysql'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with optional dependencies', () => {
    const noop = () => {};

    const baseProvider = async ({
      ENV,
      log = noop,
      debug: aDebug = noop
    }) => async () => ({
      ENV,
      log,
      aDebug
    });

    const dependencies = ['ENV', '?log', '?debug'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with several arguments', () => {
    const noop = () => {};

    const baseProvider = async ({
      ENV,
      log = noop,
      debug: aDebug = noop
    }, {
      userId
    }) => async () => ({
      ENV,
      log,
      aDebug,
      userId
    });

    const dependencies = ['ENV', '?log', '?debug'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should allow to decorate an initializer with complex arguments', () => {
    const noop = () => {};

    const baseProvider = async ({
      ENV,
      log = noop,
      debug: aDebug = noop
    }, {
      userId,
      currentTime = Date.now()
    }) => async () => ({
      ENV,
      log,
      aDebug,
      userId,
      currentTime
    });

    const dependencies = ['ENV', '?log', '?debug'];
    const newInitializer = (0, _util.autoInject)(baseProvider);

    _assert.default.notEqual(newInitializer, baseProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);
  });
  it('should fail with non async initializers', () => {
    _assert.default.throws(() => {
      (0, _util.autoInject)(({
        foo: bar = {
          bar: 'foo'
        }
      }) => {
        return bar;
      });
    }, /E_NON_ASYNC_INITIALIZER/);
  });
  it('should fail with too complex injections', () => {
    _assert.default.throws(() => {
      (0, _util.autoInject)(async ({
        foo: bar = {
          bar: 'foo'
        }
      }) => {
        return bar;
      });
    }, /E_AUTO_INJECTION_FAILURE/);
  });
  it('should fail with no injections', () => {
    _assert.default.throws(() => {
      (0, _util.autoInject)(async () => {});
    }, /E_AUTO_INJECTION_FAILURE/);
  });
});
describe('alsoInject', () => {
  it('should allow to decorate an initializer with dependencies', () => {
    const newInitializer = (0, _util.alsoInject)(['ENV'], (0, _util.inject)(['TEST'], aProvider));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['TEST', 'ENV']);
  });
  it('should allow to decorate an initializer with dependencies', () => {
    const newInitializer = (0, _util.alsoInject)(['ENV'], aProvider);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);
  });
  it('should dedupe dependencies', () => {
    const newInitializer = (0, _util.alsoInject)(['ENV', '?NODE_ENV', '?TEST', 'mysql>db'], (0, _util.alsoInject)(['ENV', 'NODE_ENV', '?TEST', 'mysql'], aProvider));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV', 'NODE_ENV', '?TEST', 'mysql', 'mysql>db']);
  });
});
describe('parseInjections', () => {
  it('should work with TypeScript dependencies', () => {
    _assert.default.deepEqual((0, _util.parseInjections)(`async function initNexmo({
      ENV,
      NEXMO,
      log = noop,
    }: {
      ENV: any;
      NEXMO: any;
      log: Function;
    }): Promise<SMSService> {}`), ['ENV', 'NEXMO', '?log']);
  });
  it('should allow to decorate an initializer with dependencies', () => {
    const newInitializer = (0, _util.alsoInject)(['ENV'], aProvider);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);
  });
});
describe('options', () => {
  it('should allow to decorate an initializer with options', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, aProvider, false));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);
  });
  it('should allow to decorate an initializer with options', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const rootOptions = {
      yolo: true,
      singleton: false
    };
    const baseOptions = {
      singleton: true
    };
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, (0, _util.options)(rootOptions, aProvider), true));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], rootOptions);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], _objectSpread({}, rootOptions, baseOptions));
  });
});
describe('name', () => {
  it('should allow to decorate an initializer with a name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, (0, _util.name)(baseName, aProvider)));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
});
describe('autoName', () => {
  it('should allow to decorate an initializer with its function name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, (0, _util.autoName)(async function hash() {})));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should allow to decorate an initializer with its init like function name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, (0, _util.autoName)(async function initHash() {})));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should allow to decorate an initializer with its initialize like function name', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, (0, _util.autoName)(async function initializeHash() {})));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should allow to decorate a bounded initializer', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const newInitializer = (0, _util.autoName)((0, _util.inject)(dependencies, (0, _util.options)(baseOptions, async function initializeHash() {})));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);
  });
  it('should fail with anonymous functions', () => {
    _assert.default.throws(() => {
      (0, _util.autoName)(async () => {});
    }, /E_AUTO_NAMING_FAILURE/);
  });
});
describe('extra', () => {
  it('should allow to decorate an initializer with extra infos', () => {
    const extraInformations = {
      httpHandler: true
    };
    const newInitializer = (0, _util.extra)(extraInformations, aProvider);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);
  });
  it('should allow to decorate an initializer with extra infos', () => {
    const extraInformations = {
      httpHandler: true
    };
    const newInitializer = (0, _util.extra)(extraInformations, aProvider, true);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], extraInformations);
  });
  it('should allow to decorate an initializer with additional extra infos', () => {
    const baseExtraInformations = {
      yolo: true,
      httpHandler: false
    };
    const additionalExtraInformations = {
      httpHandler: true
    };
    const newInitializer = (0, _util.extra)(baseExtraInformations, (0, _util.extra)(additionalExtraInformations, aProvider), true);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], baseExtraInformations);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], baseExtraInformations);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.EXTRA], _objectSpread({}, baseExtraInformations, baseExtraInformations));
  });
});
describe('type', () => {
  it('should allow to decorate an initializer with a type', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, (0, _util.name)(baseName, (0, _util.type)(baseType, aProvider))));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
});
describe('initializer', () => {
  it('should allow to decorate an initializer with every properties', () => {
    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.initializer)({
      inject: dependencies,
      options: baseOptions,
      type: baseType,
      name: baseName
    }, aProvider);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should fail with bad properties', () => {
    _assert.default.throws(() => {
      (0, _util.initializer)({
        name: 'yolo',
        yolo: ''
      }, async () => {});
    }, /E_BAD_PROPERTY/);
  });
});
describe('constant', () => {
  it('should allow to create an initializer from a constant', async () => {
    const baseValue = 'THE_VALUE';
    const baseName = 42;
    const newInitializer = (0, _util.constant)(baseName, baseValue);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], []);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], {
      singleton: true
    });

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'constant');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.VALUE], baseValue);

    _assert.default.equal((await newInitializer()), baseValue);
  });
  it('should fail with dependencies since it makes no sense', () => {
    _assert.default.throws(() => {
      (0, _util.constant)('time', (0, _util.inject)(['hash3'], async () => {}));
    }, /E_CONSTANT_INJECTION/);
  });
});
describe('service', () => {
  it('should allow to create an initializer from a service builder', async () => {
    const aServiceBuilder = async () => {};

    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.service)(aServiceBuilder, baseName, dependencies, baseOptions);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should allow to create an initializer from a service builder', async () => {
    const aServiceBuilder = async () => {};

    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const baseType = 'service';
    const newInitializer = (0, _util.service)((0, _util.name)(baseName, (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, aServiceBuilder))));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should fail with no service builder', () => {
    _assert.default.throws(() => {
      (0, _util.service)();
    }, /E_NO_SERVICE_BUILDER/);
  });
});
describe('autoService', () => {
  it('should detect the service details', () => {
    const baseServiceBuilder = async function initializeMySQL({
      ENV
    }) {
      return ENV;
    };

    const newInitializer = (0, _util.autoService)(baseServiceBuilder);

    _assert.default.notEqual(newInitializer, baseServiceBuilder);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'service');
  });
  it('should detect the service details even with no dependencies', () => {
    const baseServiceBuilder = async function initializeMySQL() {
      return;
    };

    const newInitializer = (0, _util.autoService)(baseServiceBuilder);

    _assert.default.notEqual(newInitializer, baseServiceBuilder);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], []);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'service');
  });
});
describe('provider', () => {
  it('should allow to create an initializer from a provider builder', async () => {
    const aServiceBuilder = async () => {};

    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const baseType = 'provider';
    const newInitializer = (0, _util.provider)(aServiceBuilder, baseName, dependencies, baseOptions);

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should allow to create an initializer from a provider builder', async () => {
    const aServiceBuilder = async () => {};

    const dependencies = ['ANOTHER_ENV>ENV'];
    const baseOptions = {
      singleton: true
    };
    const baseName = 'hash';
    const baseType = 'provider';
    const newInitializer = (0, _util.provider)((0, _util.name)(baseName, (0, _util.inject)(dependencies, (0, _util.options)(baseOptions, aServiceBuilder))));

    _assert.default.notEqual(newInitializer, aProvider);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], dependencies);

    _assert.default.notEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.OPTIONS], baseOptions);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], baseName);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], baseType);
  });
  it('should fail with no provider builder', () => {
    _assert.default.throws(() => {
      (0, _util.provider)();
    }, /E_NO_PROVIDER_BUILDER/);
  });
});
describe('autoProvider', () => {
  it('should detect the provider details', () => {
    const baseInitializer = async function initializeMySQL({
      ENV
    }) {
      return ENV;
    };

    const newInitializer = (0, _util.autoProvider)(baseInitializer);

    _assert.default.notEqual(newInitializer, baseInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], ['ENV']);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'provider');
  });
  it('should detect the provider details even with no dependencies', () => {
    const baseInitializer = async function initializeMySQL() {
      return;
    };

    const newInitializer = (0, _util.autoProvider)(baseInitializer);

    _assert.default.notEqual(newInitializer, baseInitializer);

    _assert.default.deepEqual(newInitializer[_util.SPECIAL_PROPS.INJECT], []);

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.NAME], 'mySQL');

    _assert.default.equal(newInitializer[_util.SPECIAL_PROPS.TYPE], 'provider');
  });
});
describe('handler', () => {
  it('should work', async () => {
    const baseName = 'sampleHandler';
    const injectedServices = ['kikooo', 'lol'];
    const services = {
      kikooo: 'kikooo',
      lol: 'lol'
    };
    const theInitializer = (0, _util.handler)(sampleHandler, baseName, injectedServices);

    _assert.default.deepEqual(theInitializer.$name, baseName);

    _assert.default.deepEqual(theInitializer.$inject, injectedServices);

    const theHandler = await theInitializer(services);
    const result = await theHandler('test');

    _assert.default.deepEqual(result, {
      deps: services,
      args: ['test']
    });

    function sampleHandler(deps, ...args) {
      return Promise.resolve({
        deps,
        args
      });
    }
  });
  it('should fail with no name', () => {
    _assert.default.throws(() => {
      (0, _util.handler)(() => {});
    }, /E_NO_HANDLER_NAME/);
  });
});
describe('autoHandler', () => {
  it('should work', async () => {
    const services = {
      kikooo: 'kikooo',
      lol: 'lol'
    };
    const theInitializer = (0, _util.autoHandler)(sampleHandler);

    _assert.default.deepEqual(theInitializer.$name, sampleHandler.name);

    _assert.default.deepEqual(theInitializer.$inject, ['kikooo', 'lol']);

    const theHandler = await theInitializer(services);
    const result = await theHandler('test');

    _assert.default.deepEqual(result, {
      deps: services,
      args: ['test']
    });

    async function sampleHandler({
      kikooo,
      lol
    }, ...args) {
      return Promise.resolve({
        deps: {
          kikooo,
          lol
        },
        args
      });
    }
  });
  it('should fail for anonymous functions', () => {
    _assert.default.throws(() => {
      (0, _util.autoHandler)(() => {});
    }, /E_AUTO_NAMING_FAILURE/);
  });
});
describe('parseDependencyDeclaration', () => {
  it('should work', () => {
    _assert.default.deepEqual((0, _util.parseDependencyDeclaration)('pgsql>db'), {
      serviceName: 'pgsql',
      mappedName: 'db',
      optional: false
    });
  });
});